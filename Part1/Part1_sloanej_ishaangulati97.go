package main

import (
	"fmt"
	"math"
	"os"
	"strings"
	"unicode"
)

// we use an ordered list to represent the symbal table
type symbol struct {
	symbol_index int
	token        string
	decimal_val  int
}

type operator struct {
	lexeme string
	token  string
}

type SyntaxTree struct {
	value symbol
	left  *SyntaxTree
	right *SyntaxTree
}

const (
	roman_symbols = "IVXLCDM"
)

var (
	input_str string = ""

	lexemes      []string
	lexeme_index int = 0

	next_token string

	symbol_table [100]symbol

	operators = []operator{
		operator{
			lexeme: "plus",
			token:  "ADD_OP",
		},
		operator{
			lexeme: "minus",
			token:  "SUB_OP",
		},
		operator{
			lexeme: "times",
			token:  "MULT_OP",
		},
		operator{
			lexeme: "divide",
			token:  "DIV_OP",
		},
		operator{
			lexeme: "modulo",
			token:  "MOD_OP",
		},
		operator{
			lexeme: "power",
			token:  "POW_OP",
		},
	}
)

func main() {

	// read input from command line argument
	if len(os.Args) != 2 {
		fmt.Println("Please enter an expression in quotes")
		return
	}
	input_str = os.Args[1]
	/* format input by detatching parenthesis, and splitting input into string
	slice using " " delimiter. */
	formatInput()
	recursiveDescentParse()

}

// attempt to tokenize the next lexeme
func lex() {

	// no more lexemes to tokenize
	if lexeme_index >= len(lexemes) {
		lexeme_index++
		next_token = "EOF"
		return
	}

	lexeme := lexemes[lexeme_index]

	// used to store the decimal value of a roman numeral
	roman_num := 0

	// if the lexeme is uppercase and starts with a letter, evaluate as a roman numeral
	r := []rune(lexeme)
	if strings.ToUpper(lexeme) == lexeme && unicode.IsLetter(r[0]) {
		roman_num = toArabic(lexeme)
		next_token = "NUM"

	} else if unicode.IsLetter(r[0]) { // else if lexeme starts with a letter, evaluate as operator
		op_index := 0
		for op_index = range operators {
			if operators[op_index].lexeme == lexeme {
				next_token = operators[op_index].token
				break
			}

			// if no operators are found - its a lexical error
			if op_index+1 == len(operators) {
				lexicalError()
			}
		}

	} else { // else evaluate as paren
		switch lexeme {
		case "(", "{", "[":
			next_token = "OPEN_PAREN"
		case ")", "}", "]":
			next_token = "CLOSE_PAREN"

		default:
			lexicalError()
		}
	}

	// add token to symbol table
	symbol_table[lexeme_index].symbol_index = lexeme_index
	symbol_table[lexeme_index].token = next_token
	if next_token == "NUM" {
		symbol_table[lexeme_index].decimal_val = roman_num
	}

	// get ready for next call to lex
	lexeme_index++
}

// starts the recursive descent parsing process by calling the root parsing subprogram
func recursiveDescentParse() {
	// get first token
	lex()
	// attempt to parse the input token by token
	tree := expr()
	var result int = getResult(tree)
	fmt.Println(convertToRoman(result))
}

/*****************************************************************/
//  recursive-descent parsing subprograms
/*****************************************************************/

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> { (ADD_OP | SUB_OP) <term> }
*/
func expr() *SyntaxTree {
	// Parse the first term
	node := term()

	//As long as the next token is ADD_OP or SUB_OP, get the next token and parse the next term
	for next_token == "ADD_OP" || next_token == "SUB_OP" {
		var temp symbol = symbol_table[lexeme_index-1]
		lex()
		node = &SyntaxTree{left: node, value: temp, right: term()}
	}
	return node
}

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> { (MULT_OP | DIV_OP | MOD_OP) <factor> }
*/
func term() *SyntaxTree {
	// Parse the first factor
	node := exponential()
	// As long as the next token is MULT_OP or DIV_OP or MOD_OP, get the next token and parse the next factor */
	for next_token == "MULT_OP" || next_token == "DIV_OP" || next_token == "MOD_OP" {
		var temp symbol = symbol_table[lexeme_index-1]
		lex()
		node = &SyntaxTree{left: node, value: temp, right: exponential()}
	}
	return node
}

func exponential() *SyntaxTree {
	node := factor()
	for next_token == "POW_OP" {
		var temp symbol = symbol_table[lexeme_index-1]
		lex()
		node = &SyntaxTree{left: node, value: temp, right: exponential()}
	}
	return node
}

/* factor
Parses strings in the language generated by the rule:
<factor> -> NUM [POW_OP <expr>]
		 -> OPEN_PAREN <expr> CLOSE_PAREN [POW_OP <expr>]
*/
func factor() *SyntaxTree {
	// Determine which RHS
	var node *SyntaxTree = nil
	if next_token == "NUM" {
		var temp symbol = symbol_table[lexeme_index-1]
		lex()
		node = &SyntaxTree{value: temp, left: nil, right: nil}
		/* If the RHS is OPEN_PAREN <expr> CLOSE_PAREN <optionexp>, call lex to pass over the
		OPEN_PAREN, call expr, and make sure there's a the CLOSE_PAREN
		is POW_OP */
	} else {
		if next_token == "OPEN_PAREN" {
			lex()
			node = expr()
			if next_token == "CLOSE_PAREN" {
				lex()
			} else {
				// there was no CLOSE_PAREN
				syntaxError()
			}

		} else {
			// It was not an NUM, or an OPEN_PAREN
			syntaxError()
		}
	} /* End of else */
	return node
}

/*****************************************************************/
// helper functions
/*****************************************************************/

// detatch parenthesis and split input into string slice using " " delimiter
func formatInput() {

	input_str = strings.TrimSpace(input_str)
	input_slice := strings.Split(input_str, "")
	str := ""
	for index := range input_slice {
		if isParen(input_slice[index]) {
			if str != "" {
				lexemes = append(lexemes, str)
				lexemes = append(lexemes, input_slice[index])
				str = ""
			} else {
				lexemes = append(lexemes, input_slice[index])
			}
		} else if input_slice[index] == " " {
			if str != "" {
				lexemes = append(lexemes, str)
			}
			str = ""
		} else {
			str += input_slice[index]
		}

		if index == len(input_slice)-1 && str != "" {
			lexemes = append(lexemes, str)
		}
	}
	// check if input is longer than symbol table capacity
	if len(lexemes) > len(symbol_table) {
		fmt.Println("ERROR: Input too long")
	}
}

func isParen(str string) bool {
	if str == "(" || str == "{" || str == "[" || str == ")" || str == "}" || str == "]" {
		return true
	}
	return false
}

// returns the decimal value of a roman numeral
func toArabic(numeral string) int {

	// base case
	if numeral == "" {
		return 0
	}

	// invalid syntax
	if strings.HasPrefix(numeral, "IL") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "IC") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "ID") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "IM") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "VX") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "VL") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "VC") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "VD") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "VM") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "XD") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "XM") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "LC") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "LD") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "LM") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "DM") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "IIII") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "VV") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "XXXX") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "LL") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "CCCC") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "DD") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "MMMM") {
		lexicalError()
	}

	// special invalid syntax
	if strings.HasPrefix(numeral, "CM") && (numeral[2:3] == "C" || numeral[2:3] == "D" || numeral[2:3] == "M") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "CD") && (numeral[2:3] == "C" || numeral[2:3] == "D" || numeral[2:3] == "M") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "XC") && !(numeral[2:3] == "V" || numeral[2:3] == "I") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "XL") && !(numeral[2:3] == "V" || numeral[2:3] == "I") {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "IX") && numeral[2:] != "" {
		lexicalError()
	}
	if strings.HasPrefix(numeral, "IV") && numeral[2:] != "" {
		lexicalError()
	}

	// valid syntax
	if strings.HasPrefix(numeral, "M") {
		return (1000 + toArabic(numeral[1:]))
	}
	if strings.HasPrefix(numeral, "CM") {
		return (900 + toArabic(numeral[2:]))
	}
	if strings.HasPrefix(numeral, "D") {
		return (500 + toArabic(numeral[1:]))
	}
	if strings.HasPrefix(numeral, "CD") {
		return (400 + toArabic(numeral[2:]))
	}
	if strings.HasPrefix(numeral, "C") {
		return (100 + toArabic(numeral[1:]))
	}
	if strings.HasPrefix(numeral, "XC") {
		return (90 + toArabic(numeral[2:]))
	}
	if strings.HasPrefix(numeral, "L") {
		return (50 + toArabic(numeral[1:]))
	}
	if strings.HasPrefix(numeral, "XL") {
		return (40 + toArabic(numeral[2:]))
	}
	if strings.HasPrefix(numeral, "X") {
		return (10 + toArabic(numeral[1:]))
	}
	if strings.HasPrefix(numeral, "IX") {
		return (9 + toArabic(numeral[2:]))
	}
	if strings.HasPrefix(numeral, "V") {
		return (5 + toArabic(numeral[1:]))
	}
	if strings.HasPrefix(numeral, "IV") {
		return (4 + toArabic(numeral[2:]))
	}
	if strings.HasPrefix(numeral, "I") {
		return (1 + toArabic(numeral[1:]))
	}

	// if execution makes it here, something went wrong
	lexicalError()
	return 0
}

// format output to point to proper lexeme
func lexicalError() {
	printError(lexeme_index, "Quid dicis? You offend Caesar with your sloppy lexical habits!")
}

// format output to point to proper lexeme
func syntaxError() {
	printError(lexeme_index-1, "Quid dicis? True Romans would not understand your syntax!")
}

func getResult(node *SyntaxTree) int {
	var nodeType string = getNodeType(node)
	if nodeType == "NUM" {
		return node.value.decimal_val
	}
	return calculateResult(node)
}

func calculateResult(node *SyntaxTree) int {
	var operatorToken string = node.value.token
	var index int = node.value.symbol_index
	temp := 0
	switch operatorToken {
	case "ADD_OP":
		temp = getResult(node.left) + getResult(node.right)
		break
	case "SUB_OP":
		temp = getResult(node.left) - getResult(node.right)
		break
	case "MULT_OP":
		temp = getResult(node.left) * getResult(node.right)
		break
	case "DIV_OP":
		temp = getResult(node.left) / getResult(node.right)
		break
	case "MOD_OP":
		temp = getResult(node.left) % getResult(node.right)
		break
	case "POW_OP":
		var arg1 = getResult(node.left)
		var arg2 = getResult(node.right)
		temp = int(math.Pow(float64(arg1), float64(arg2)))
		break
	}
	raiseCalculateError(temp, index)
	return temp
}

func printError(index int, message string) {

	fmt.Println(input_str)

	space_count := 0

	for i := 0; i < index; i++ {
		if isParen(lexemes[i]) {
			space_count += 1
		} else if i == len(lexemes)-1 {
			space_count += len(lexemes[i])
		} else {
			space_count += (len(lexemes[i]) + 1)
		}
	}

	for i := 0; i < space_count; i++ {
		fmt.Printf(" ")
	}
	fmt.Println("^")
	fmt.Println(message)
	os.Exit(3)
}

func raiseCalculateError(value int, index int) {
	if value == 0 {
		printError(index, "Quid dicis? Arab merchants haven't left for India yet!")
	}
	if value < 0 {
		printError(index, "Quid dicis? Caesar demands positive thoughts!")
	}

}

func getNodeType(node *SyntaxTree) string {
	if node.value.token == "NUM" {
		return "NUM"
	}
	return "OPERATOR"

}

/*
Reference: https://www.geeksforgeeks.org/converting-decimal-number-lying-between-1-to-3999-to-roman-numerals/
*/

func convertToRoman(number int) string {
	num := [...]int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}
	sym := [...]string{"I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"}
	resp := ""
	i := 12
	for number > 0 {
		div := number / num[i]
		number = number % num[i]
		for div > 0 {
			resp += sym[i]
			div -= 1
		}
		i--
	}
	return resp
}
