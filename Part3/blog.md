Over the past few weeks a teammate and I have implemented a roman numeral calculator. This command-line program accepts arithmetic expressions containing roman numerals and either computes the result or gives an error - when the entered expression does not adhere to the proper format. Developing this program required the application of programming language compilation concepts like lexical analysis, syntax analysis, and semantic analysis. In this sense, I treated the “correct format” for roman numeral arithmetic expressions as a language - which I described and parsed using a formal grammar.

As a bit of background, I am a graduate computer science student, and I have studied grammars and parsing algorithms before, but developing this roman numeral calculator was still a tough challenge. First of all, I wrote this program using the Go programming language - which I have never used before. My experience with Go was overall positive. There are numerous resources for learning the language, and my prior experience with C and C++ helped escalate the learning process - as Go shares many syntactic similarities with C. One particular feature of Go that I enjoyed was the global variable grouping under the “Variable Declaration Block.” This allows for variable declarations to be grouped together into blocks for greater readability and code quality.

When tackling the roman numeral calculator problem, I started with the development of the lexer. The lexer is the part of a compiler that deals with tokenizing an input to prepare it for syntax analysis via the parser. This part was more straightforward than the parser element, but was still challenging because I had to keep in mind how the lexer would fit into the program at large - I had to consider the future functionality of the parser. I got the hang of Go while writing the lexer, and by the time I was implementing the parser I felt fairly comfortable with the new language. 

Before I was able to implement the parser, I needed to stop and construct a more comprehensive implementation design. This required the review of course material surrounding EBNF grammars and parsing algorithms. I spent a lot of time figuring out the right EBNF grammar to describe the language used in the roman numeral calculator. This involved significant trial and error - as intermediate drafts of the grammar contained left recursion and/or pairwise disjointness that needed to be removed to arrive at the final grammar. I would ultimately use this grammar as the basis for a sequence of recursive descent subprograms used to perform syntax analysis. In the end, this project was a fun challenge as it required a deep level of understanding of compiler concepts and grammars while falling under a unique historical theme with roman numerals and Latin prose.
